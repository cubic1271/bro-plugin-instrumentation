%%{

#include <string>
#include "Val.h"
#include "Plugin.h"

%%}

module Instrumentation;

function SetCollectionTimer%(target: double%): bool
	%{
	plugin::Instrumentation::plugin.SetCollectionTimer(target);
	return new Val(1, TYPE_BOOL);
	%}

function SetCollectionCount%(target: int%): bool
	%{
	plugin::Instrumentation::plugin.SetCollectionCount((uint64_t)target);
	return new Val(1, TYPE_BOOL);
	%}

function SetCollectionTarget%(target: string%): bool
	%{
	plugin::Instrumentation::plugin.SetCollectionTarget(std::string((char *)target->Bytes()));
	return new Val(1, TYPE_BOOL);
	%}

function CollectionFlush%(%): bool
	%{
	plugin::Instrumentation::plugin.FlushCollection();
	return new Val(1, TYPE_BOOL);
	%}

function SetFunctionDataTarget%(target: string%): bool
	%{
	plugin::Instrumentation::plugin.SetFunctionDataTarget(std::string((char *)target->Bytes()));
	return new Val(1, TYPE_BOOL);
	%}

function FunctionDataWrite%(%): bool
	%{
	plugin::Instrumentation::plugin.WriteFunctionData();
	return new Val(1, TYPE_BOOL);
	%}

function SetChainDataTarget%(target: string%): bool
	%{
	plugin::Instrumentation::plugin.SetChainDataTarget(std::string((char *)target->Bytes()));
	return new Val(1, TYPE_BOOL);
	%}

function SetChainDataCutoff%(target: int%): bool
	%{
	if(target < 0) {
		target = 0;
	}
	plugin::Instrumentation::plugin.SetChainDataCutoff((uint64_t)target);
	return new Val(1, TYPE_BOOL);
	%}

function ChainDataWrite%(%): bool
	%{
	plugin::Instrumentation::plugin.WriteChainData();
	return new Val(1, TYPE_BOOL);
	%}
